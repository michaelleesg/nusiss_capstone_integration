Paste-Ready Mega-Prompt for 13-Oct

Title: CyberSage – Agent B (HEVA) Upgrade, Tests, Containerization to AWS, and Slide Hooks (Deadline: 13-Oct-2025)

ROLE (You = Lead Engineer + Planner + Docs Assistant)
You are an exacting AI pair-programmer and release planner for Team 9’s CyberSage project. You will propose minimal, pragmatic patches that compile, run, and ship under time pressure. You will also generate tests, ops files, and presentation snippets for reuse on 13-Oct.

CONTEXT

Project: CyberSage multi-agent CTI platform (Agents A–D).

Agent B (HEVA) = Historical Evidence & Vector Archive. Stores normalized artifacts from Agent A into a vector DB (Qdrant). Serves retrieval for Agent C.

Default local dir (WSL): /mnt/c/Users/mike/Downloads/capstone

Target deploy: AWS (prefer App Runner or ECS Fargate), image hosted on ECR.

Deadline: Final presentation 13-Oct-2025 (Mon); slides need code & ops screenshots, short explainer, and a diagram.

Non-goals: Do not re-architect Agent A/C/D beyond the contracts; minimize churn.

OBJECTIVES

Update Agent B codebase (structure, env, endpoints, logging, reliability).

Containerize Agent B; provide local docker-compose with Qdrant for dev.

Ship to AWS (ECR + App Runner or ECS Fargate). Include IaC-lite or a GitHub Actions workflow.

Add tests (unit + integration) for Agent B (incl. vector write/read and FastAPI endpoints).

Provide an agentic workflow for Agent B (retrieval pipeline, confidence, and fallbacks).

Generate slide-ready assets: (a) short summary bullets, (b) architecture diagram (Mermaid), (c) “what changed” changelog, (d) one-liner demo script.

INPUT HINTS (read project if present)

Files often include: 3_search_api_rich.py (FastAPI), hybrid_ner_pipeline.py, ingestion JSON schema excerpt, Qdrant configs, and scripts under repo root.

Prior issues: Qdrant container healthcheck; dimension mismatch; overlapping code blocks in docs; LaTeX report alignment.

TASKS & DELIVERABLES
A) Codebase Update (Agent B)

Do:

Create/ensure a clean module layout:

agent_b_heva/
  __init__.py
  app.py                   # FastAPI entry (GET /health, POST /upsert, POST /search)
  vector_store.py          # Qdrant client wrapper (connect, create collection, upsert, query)
  schemas.py               # Pydantic: DocumentIn, QueryIn, SearchResult
  settings.py              # Pydantic Settings for env vars
  logging_conf.py
  tests/
    test_vector_store.py
    test_app_endpoints.py


Env variables via .env:

QDRANT_URL, QDRANT_API_KEY (optional), QDRANT_COLLECTION=heva_docs, EMBED_MODEL=all-MiniLM-L6-v2, VECTOR_DIM=384.

Add robust init: create collection if missing, index on payload keys (cve_ids, vendors, attck).

Endpoints:

GET /health → {status:"ok", qdrant: "ok"}

POST /upsert → body: [DocumentIn] (id, title, body, metadata, embedding? optional). If no embedding provided, compute (stub hook for now if model runs elsewhere).

POST /search → body: QueryIn{text, top_k, filters?} returns ranked SearchResult[] with scores and evidence snippets.

Logging: JSON logs with request id; warn on dimension mismatch; graceful degrade if Qdrant blocked.

Deliver:

Patched code files (complete).

README.md quick start (local & AWS).

CHANGELOG.md with date-stamped entries.

B) Containerization (Local Dev)

Produce:

Dockerfile (multi-stage, Python 3.11, installs FastAPI/uvicorn, qdrant-client, pydantic, httpx, pytest).

docker-compose.yml for local dev:

Services: heva (Agent B), qdrant (official image).

Healthchecks; depends_on; volumes for Qdrant storage.

.env.example with sane defaults.

C) AWS Deployment (Pick one: fast path first)

Option 1 – App Runner (fastest):

GitHub Actions workflow:

Build & push to ECR.

Create/Update App Runner service with image URI, port 8000, env vars, min 1 instance.
Option 2 – ECS Fargate (more control):

Task def JSON (CPU/mem 0.5/1GB), service, ALB, target group, SG.

GitHub Actions to register task def and update service.

Deliver:

.github/workflows/deploy.yml (ECR login, docker buildx, push, deploy step).

infra/apprunner.md or infra/ecs/README.md with one-page instructions.

D) Testing (Pytest)

Unit: test_vector_store.py (create temp collection, upsert 2 docs, query, assert order/scores).

Integration: test_app_endpoints.py using httpx.AsyncClient against running app (or TestClient), mocks for Qdrant if needed.

Provide Makefile (or simple script) targets: make test, make run, make build, make up.

E) Agentic Workflow (Agent B)

Implement/design a simple LangGraph-style flow (documented + code hook):

Nodes: SanitizeInput → EmbedOrRoute → VectorSearch → EvidencePack → Rerank(Optional) → Respond.

Policies:

If filters present (CVE/CPE/ATT&CK/vendor), bias retrieval with payload filters.

Add confidence score and explainability trail (which fields matched, top-k scores).

Fallbacks: if vector service down, return payload-only keyword match (graceful degrade with warning).

Deliver:

agent_b_heva/graph.py (skeleton with TODOs + docstrings).

Diagram (Mermaid) embedded in README.md.

F) Slide Hooks for 13-Oct

Generate:

Mermaid diagram (architecture + agent flow).

6 bullet talk track for Agent B (90 seconds).

“Before/After” diff bullets (what changed since last week).

One screenshot checklist (Docker, App Runner/ECS console, /health JSON, pytest summary).

Keep a memory note with the exact bullets and diagram block (store for later retrieval).

CODE & FILES TO OUTPUT

Create or update these files (show final contents):

agent_b_heva/app.py, vector_store.py, schemas.py, settings.py, logging_conf.py, graph.py

tests/test_vector_store.py, tests/test_app_endpoints.py

Dockerfile, docker-compose.yml, .env.example

.github/workflows/deploy.yml

README.md, CHANGELOG.md, infra/apprunner.md or infra/ecs/README.md

Provide complete, minimal, production-lean code (no placeholders that break CI). Prefer small, readable files.

SNIPPET GUIDES (you may refine while generating)

Dockerfile (Python 3.11, uvicorn)

FROM python:3.11-slim AS base
WORKDIR /app
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1
RUN apt-get update && apt-get install -y --no-install-recommends build-essential && rm -rf /var/lib/apt/lists/*
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY agent_b_heva/ ./agent_b_heva/
EXPOSE 8000
CMD ["uvicorn", "agent_b_heva.app:app", "--host", "0.0.0.0", "--port", "8000"]


docker-compose.yml (local dev)

version: "3.9"
services:
  qdrant:
    image: qdrant/qdrant:latest
    ports: ["6333:6333"]
    volumes:
      - qdrant-storage:/qdrant/storage
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:6333/ready"]
      interval: 10s
      timeout: 3s
      retries: 10

  heva:
    build: .
    env_file: .env
    ports: ["8000:8000"]
    depends_on:
      qdrant:
        condition: service_healthy

volumes:
  qdrant-storage:


.github/workflows/deploy.yml (ECR + App Runner path)

name: deploy-heva
on:
  push:
    branches: [ main ]
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ap-southeast-1
      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build and push
        run: |
          REPO=${{ secrets.ECR_REPO }}
          IMAGE=$REPO:heva-${GITHUB_SHA::7}
          docker build -t $IMAGE .
          docker push $IMAGE
          echo "IMAGE_URI=$IMAGE" >> $GITHUB_ENV
      - name: Deploy to App Runner
        run: |
          aws apprunner update-service --service-arn ${{ secrets.APP_RUNNER_ARN }} \
            --source-configuration ImageRepository="{ImageIdentifier=${IMAGE_URI},ImageRepositoryType=ECR,ImageConfiguration={Port=8000,RuntimeEnvironmentVariables=[{Name=QDRANT_URL,Value=${{ secrets.QDRANT_URL }}},{Name=QDRANT_API_KEY,Value=${{ secrets.QDRANT_API_KEY }}},{Name=QDRANT_COLLECTION,Value=heva_docs},{Name=VECTOR_DIM,Value=384}]}}"


FastAPI skeleton (agent_b_heva/app.py)

from fastapi import FastAPI, HTTPException
from .schemas import DocumentIn, QueryIn, SearchResult
from .vector_store import VectorStore
from .settings import Settings

app = FastAPI(title="CyberSage Agent B (HEVA)")
settings = Settings()
store = VectorStore(settings)

@app.get("/health")
def health():
    ok = store.health()
    return {"status": "ok" if ok else "degraded", "qdrant": ok}

@app.post("/upsert")
def upsert(docs: list[DocumentIn]):
    try:
        n = store.upsert_documents(docs)
        return {"upserted": n}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/search", response_model=list[SearchResult])
def search(q: QueryIn):
    try:
        return store.search(q)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


Pytest example (tests/test_vector_store.py)

import pytest
from agent_b_heva.settings import Settings
from agent_b_heva.vector_store import VectorStore
from agent_b_heva.schemas import DocumentIn, QueryIn

def test_roundtrip():
    s = Settings()
    vs = VectorStore(s, collection="heva_test")
    vs.ensure_collection()
    docs = [
        DocumentIn(id="1", title="CVE-2025-12345 Cisco IOS XE", body="Remote code execution", metadata={"cve_ids":["CVE-2025-12345"],"vendors":["Cisco"]}),
        DocumentIn(id="2", title="ATT&CK T1190 exploit", body="Exploit public-facing app", metadata={"attck":["T1190"]}),
    ]
    assert vs.upsert_documents(docs) == 2
    res = vs.search(QueryIn(text="Cisco exploit", top_k=2))
    assert len(res) >= 1


Mermaid (architecture + flow)

flowchart LR
  A[Agent A: Normalized JSON] -->|ingest| B[Agent B (HEVA): Qdrant]
  B -->|/search| C[Agent C: Triage]
  subgraph Agent B Flow
  S[SanitizeInput] --> E[EmbedOrRoute] --> V[VectorSearch] --> P[EvidencePack] --> R[Rerank?] --> O[Respond]
  end


Slide bullets (90s talk track)

Agent B (HEVA) persists normalized CTI into Qdrant and serves high-recall retrieval for Agent C.

New: containerized service, App Runner deploy, /health, /upsert, /search endpoints.

Reliability: auto-create collection; graceful degrade; JSON logs; env-based settings.

Quality: unit + integration tests; payload filters for CVE/CPE/ATT&CK/vendor.

Agentic flow with explainability trail and confidence scores.

Ops screenshots: Docker build, App Runner console, pytest summary, /health JSON.

ACCEPTANCE CRITERIA

docker compose up runs Qdrant + HEVA; /health returns {"status":"ok","qdrant":true}.

pytest green on local (unit + integration).

GitHub Action builds and pushes to ECR; App Runner/ECS updates successfully; public URL serves /health.

README.md enables a new teammate to reproduce in ≤15 minutes.

Slide assets present and copy-paste ready.

MEMORY & DEADLINE

Remember: deliverables and slide hooks for 13-Oct-2025.

Store: this diagram block, talk bullets, and screenshot checklist for later recall as “Agent B 13-Oct slide pack”.

NOW EXECUTE:

Inspect repo for existing Agent B files; propose precise diffs.

Output the complete files listed above (ready to copy).

Produce a one-shot demo command block for local run + cURL upsert/search.

Save the “Agent B 13-Oct slide pack” to memory for recall.

Finish with a short checklist I can track in Notion.

Notes

Prefer App Runner unless we already have ECS infra; App Runner is faster for the demo timeline.

Keep vector dim at 384 unless you detect otherwise.

If embeddings are handled elsewhere, keep a stub and accept pre-computed vectors.